<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: hack | conan @ notes:~/]]></title>
  <link href="http://ConanChou.github.io/categories/hack/atom.xml" rel="self"/>
  <link href="http://ConanChou.github.io/"/>
  <updated>2015-07-23T13:29:41-04:00</updated>
  <id>http://ConanChou.github.io/</id>
  <author>
    <name><![CDATA[Conan]]></name>
    <email><![CDATA[conanchou1412@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[格子人生]]></title>
    <link href="http://ConanChou.github.io/blog/life/hack/productivity/2014/09/01/900-months/"/>
    <updated>2014-09-01T00:18:33-04:00</updated>
    <id>http://ConanChou.github.io/blog/life/hack/productivity/2014/09/01/900-months</id>
    <content type="html"><![CDATA[<p>很久未更新日誌了，真是忙碌的一年。具體的更新就不寫在這一篇里了，長話短說是：我很好。</p>

<p>長久以來，我就有病，很多病，強迫症是之一，尤其對於時間管理。在聽說「人生只有900個月，一張A4紙就能打印出來」之後，病得更重了。所以我一直尋求一些方法去靈活地、有效地規劃（Hack）自己的人生，讓更多有意思的事情發生在這30＊30的表格里。<!--more-->曾經做了一個僅供自己使用的時間跟蹤系統來分析自己的時間都花到哪裡了，由於代碼寫得很hacky，使用也太geeky（其實我就是懶得寫文檔），就沒有開源。如果有興趣的朋友可以去試試<a href="https://www.rescuetime.com/">「RescueTime」</a>，我是受到它的啟發做的，當然我做的就比較粗陋，功能性上比它多了一個強制加鎖，即，在一段時限內不能訪問黑名單內的網站。這是幾年前的故事。</p>

<p>之後的幾年，我接觸到了一些提高效率的「方法論」，當中包括 David Allen 的
<a href="http://en.wikipedia.org/wiki/Getting_Things_Done">「GTD」</a>，以及Francesco Cirillo
的<a href="http://en.wikipedia.org/wiki/Pomodoro_Technique">「番茄時間法」</a>，當然還有一些未成大氣候的方法論，比如<a href="http://en.wikipedia.org/wiki/Gamification">「Gamification」</a>。也對他們進行了嘗試和研究。可是我並不是很喜歡當中的任何一個。</p>

<p>於是，我終於啟動了一個想了很久卻沒動作的項目，暫時定名為「OrgLife」，這個項目并不簡單，因為不僅僅是寫寫程序而已，我想要研究出一個對我來說切實可行的方法。而且即便是寫寫程序而已，我還要學好多東西才能做個稍微像樣點、不擋道的工具，我可不想再做個很buggy的工具湊合用，畢竟在用工具提高效率的時候，如果工具不好使降低了效率會讓人很沮喪。在這裡，我特指要學前端開發。雖然大學時代創業時包攬過從前端到後端的活兒，但前端是個非常活躍、日新月異的技術集，三四年沒碰的話就已經是老化的知識了……</p>

<p>剛剛我強調了我要找個對我管用的辦法，因為我不知道這個方法是否普世，但是有我這個時間管理強迫症的人還挺多的，昨天在看 Hacker News
的時候看到一個要做<a href="https://www.kickstarter.com/projects/1751759988/sicp-distilled">「SICP Distilled」</a>的小夥子，也是個 LISP
Hacker，去他博客一逛，發現他也跟我一樣，試圖在做一些 life hacking
projects。所以或許，這個所謂的工具也好，方法也好，能夠讓一部份人先「富起來」：）</p>

<p>我預感這個項目會是一個戰線比較長的戰鬥，所以在完成 OrgLife
的第一稿之前我得有一些替代品來做輔助。於是這才是今天這一篇帖子的主題：一個暫時的關於時間管理的解決方案，或許適用于大部份病得還沒那麼重的「病友」。</p>

<h2 id="section">缺失的一環</h2>

<p>GTD 是目前時間管理最成體系的一個，建議對它不了解的病友先去做一些了解。它很靠譜，，，直到最後的執行這一環。老牌黑客 Kevin Mitnic
曾經說過，人是一個系統里最薄弱的構件。這話一點不錯，人是複雜的、不可預測的、存在很多弱點的。放在現在的語境里，我們就算完全按照 GTD
的理論走，最後不執行，還是白搭。這就是我說的「缺失的一環」，也就是一個能提高人的執行力的一種輔助。</p>

<p>很巧的是番茄時間法能比較好地促進人們執行，因為人們在掐表的情況下更傾向於全神貫注、在假想的deadline前把事情做好。這其實是個很簡單有效的hack，對我還蠻有效。於是我現在的工作流程是把這兩種方法有機結合了，即，在
GTD 最後加上番茄時間；或者也可以說把番茄時間法的 TODO 管理換成了
GTD。這樣一來，我就有了一個「管用」的體系。但是這還不夠好，先賣個關子，這裡就不分析了。</p>

<h2 id="section-1">增強靈活性</h2>

<p>「Context」，或者說環境，是 GTD
里一個重要的概念，它主要是幫助你在不一樣的環境下快速找到你要做的事情。這個所謂的環境實在是一個不太好掌控的東西，因為它的定義範疇太廣了。我的建議是不要太具體，但也不要太抽象。這兩個極端會發生同樣的事情，就是你最終放棄使用
GTD。如果太具體，管理成本就會變高，你的 GTD
會變得越來越難管理，最終只能放棄；如果太抽象，這個功能等於沒有用到，因為使用成本變高。所以怎麼才算適中？這個真的因人而異。我覺得事務比較少的人相比事務多的人來說，可以稍微抽象一些。這兩個極端都是有很明顯的特徵的，如果太抽象，那你的事務列表就會很長；如果太具體，那你的很多環境分類很少被用到。用面向對象的語言寫程序的同學，這是不是很似曾相識啊？</p>

<p>下面我用我自己目前的配置舉個例子：</p>

<p><img src="https://9qbqfg.dm2303.livefilestore.com/y2p_JUt7QwduLf34NdX7GOgEmHKdRafbVYPzVBWrUsJ46nTLaNgpz9url_QM48-R8RJGxp2f4nexqW6VLzHyfkP_wVORNMyE4g1suETTYQFU4Q/Screen%20Shot%202014-08-30%20at%2010.04.28%20PM.png?psid=1" alt="" /></p>

<p>這個界面是一款完全照搬 GTD 流程的軟件，叫OmniFocus
2。它並不是唯一的選擇，只是碰巧在我寫這篇博客的時候我正在調研這款軟件。你們也看到了，它的試用期快結束了，結束了之後，我還會繼續調研
<a href="http://orgmode.org/">org-mode</a>，以及類似 <a href="https://trello.com/">Trello</a> 的其他可選方案。</p>

<p>對這些 Contexts 做一些解釋：</p>

<ul>
  <li>Errands：一些生活不得不做的瑣事，比如買菜、倒垃圾、整理房間之類的</li>
  <li>Working：工作相關
    <ul>
      <li>Office：在辦公室要做的事情</li>
      <li>Low Energy：不太想幹事的時候可以做做的事情，一般是不太費腦的無聊的活兒</li>
      <li>Waiting：在 OmniFocus 里，Context 可以設置為 Waiting 狀態，可是這個狀態下的 context
  用戶就看不到了，意思就是「這事兒不關我，等著吧」我不喜歡這個狀態，太被動了，所以我單獨另闢了一個 Waiting，卻使用跟其它 context
  一樣的狀態。這樣我就能看到正在等的工作條目，並且可以在實時的時候催一催進度。</li>
      <li>Off Duty：離開辦公室時或回家路上要做的事情</li>
    </ul>
  </li>
  <li>Learning：學習相關
    <ul>
      <li>Reading：閱讀已成為我的習慣，但是有時我缺乏專注力，經常是一本書還沒讀完就開動了第二本第三本第四本，兩個禮拜之後又拿起了第一本接著看，這樣做其實倒也沒太多弊端，就是如果忘記前文還得翻到前面複習
  目前為止我還不知道這是好是壞，因為複習可以加深記憶和理解，算是因機制而引起的反芻，是個副產品。所以這個 context
  里我主要是放兩類事務：
        <ul>
          <li>書籍閱讀進度跟蹤，這些一般都是自動循環的，比如每週前幾天是看第一本，后幾天是看另一本。這麼做同時也可以讓自己有個節制，不要太貪心，一下子開太多本……</li>
          <li>每週積累下來的時事閱讀，一般這一類都是這一週內從各個渠道搜刮到的值得閱讀的文章。用 <a href="https://ifttt.com">IFTTT</a> 和
  <a href="http://getpocket.com">Pocket</a> 自動化這個收集環節。</li>
        </ul>
      </li>
      <li>Hands Dirty：不動手肯定學不好東西，所有需要動手動腦的學習任務在這裡</li>
    </ul>
  </li>
  <li>Family：家庭相關，有跟多是跟上面的雷同的，我就不再贅述了，說說不一樣的
    <ul>
      <li>Reviewing
  Finances：我會邀請我的女朋友或家人也來參加，一般是一月一次，裡面是記錄了一些需要在檢查財政時要做的事情。</li>
      <li>Rushing Out：跟上面的「Off Duty」很像，只不過是說要出門前或出門之後在路上要做的事情</li>
    </ul>
  </li>
  <li>Anytime：不受限制，任何時間都可以做的事情</li>
</ul>

<p>適當地抽象化環境分類，可以一定程度上增強 GTD
的靈活性；交叉分類和多分類是我要說的「更進一步」，可惜目前我在調研的這個工具不支持一個事務多個分類（或者是 tag
系統）。而幾年前我摸過 org-mode，它支持 tag 系統，加上最近在寫 Clojure 和 CloJureScript，正好趁此機會撿起 Emacs 吧，Vim
我已經用了足夠久了，以至於現在沒她不行。而<a href="https://github.com/ConanChou/ConanVimrc">她的配置</a>也是我目前為止維護得最久的一個開源項目（用
Eric Steven Raymond 「大教堂和市集」里提到的理論能很好地解釋為嘛我還在一直維護，因為維護者就是使用者）。雖然我也知道有 org-mode 的
Vim 移植，但是開放的心態總沒有錯 ；）</p>

<h2 id="section-2">主次要分明</h2>

<p>我要說的概念是「優先級」，這個概念在 GTD
以及相關輔助工具里是垂直的。在單獨的項目里有優先級，但是并沒有一個橫向的優先級概念，即，項目和項目之間是平等的關係。然而這顯然是不合常理的。所以我提出的另一個修正就是項目優先級。看圖：</p>

<p><img src="https://9qbqfg.dm2303.livefilestore.com/y2pgI7vWgC8V3yoRPlMarjLCmn4lu8i_jnUZbbOm0tIFqXW7yBXeoMnAbImPigzPl8ZpDVuk88VbzO7BGWfmyDWFWgw2pZJ0OGrt3NI0jmNwc8/Screen%20Shot%202014-08-30%20at%2010.03.46%20PM.png?psid=1" alt="" /></p>

<p>上圖看上去沒什麼特別的，但是它們其實是按優先級從高到低排列的（請忽視第一個 Clojure，它本應該在 Learn and Share
里躺著的，但是截屏的時候沒注意到）。每個人的優先級可能都不太一樣，但是目前來說，我的是這樣。其中可能比較有爭議的是「Help
Others」，居然倒數第二？是的，因為我覺得幫助別人的前提條件是顧好自己，就好像在飛機上氧氣罩落下時，你應該先戴好自己的面罩再幫助你身邊的小朋友。為什麼？因為我很難想像我自己的生活工作學習在一團糟的情況下還能好好幫助別人。小時候有很多歌頌黨員幹部的影視作品，他們很多人最終是身體垮了。在我看來一方面他們的精神可貴（宣（xǐ）傳（nǎo）部的工作很到位），另一方面他們因為自己在優先級上的不理智而縮短了「為人民服務」的時間，進而減少了好官在中國黨員中的比例。這是個悲傷的故事。</p>

<h2 id="section-3">一些小竅門</h2>

<h3 id="review">不小視 Review</h3>

<p>Review 這個環節是 GTD
里很重要但是又常常被人忽視的。因為人們覺得事情做好了就結束了，我一開始也這麼覺得。後來在軟件提醒之下做了一次
review，才發現一堆漏網之魚，一些沒有加截止日期和 context 的事務。Review 其實跟處理 inbox 是一個工作模式，只是一個在 Done
之前，一個在 Done 之後。謝耳朵說自己從來不忘記東西，我們也可以，只要你 review。</p>

<h3 id="section-4">儘量自動化</h3>

<p>使用這些工具也好，方法也好，都是有額外時間和處理開銷的。（誒！學計算機科學的病友，這個是不是又似曾相識？）我稱之為管理成本，為了儘量減小管理成本，我們應該更多地使用自動化工具，比如此前提到過的
IFTTT，還有就是各種腳本。在使用 OmniFocus 階段，我嘗試寫了幾個 AppleScript 自動腳本，感受是真tm糟糕。這也是我看向 Emacs org-mode
的另一個原因。</p>

<h3 id="section-5">遞歸式批處理複雜事務</h3>

<p>GTD
的一個「遊戲規則」是必須把事務拆分成可執行的小事務，這麼做很有道理，比方說如果有一個事務叫做「寫一個操作系統」，估計很少人在900個月的時間里能夠完成這個任務；但是如果你把它拆分成細小的組成部份，比方說「寫一個引導程序」，這就可執行得多。但是拆分並不總是那麼簡單。我的方法是遞歸式＋批處理。在番茄時間里遇到複雜的事務時就把它分成較細的事務，并扔進
inbox，然後繼續其它的事務。在下一個循環時，在處理較細的事務，以此類推直到把任務做完。這麼做其實是有一定的原因的。因為其實人跟單核計算機差不多，頻繁切換工作內容會降低效率，那些自稱能高效multitask的基本都扯淡＋裝逼。所以我就把處理大數據的軟件架構設計搬了進來，即
map+reduce。這裡就點到為止吧……</p>

<h2 id="section-6">結語</h2>

<p>就先分享到這兒，感覺是還有些東西忘了提，之前本想做個腦圖的，懶了。以後想到了再補充吧，洗洗睡了。希望對病友們有幫助。</p>

<p>另外，如果有病友對 OrgLife 感興趣，請跟我聯繫 ；）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspberry Pi + Arch + WiFi + Sound + Go 簡記]]></title>
    <link href="http://ConanChou.github.io/blog/raspberry-pi/hack/arch/linux/go/2013/02/17/play-with-raspberry-pi/"/>
    <updated>2013-02-17T17:11:00-05:00</updated>
    <id>http://ConanChou.github.io/blog/raspberry-pi/hack/arch/linux/go/2013/02/17/play-with-raspberry-pi</id>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://goo.gl/RSj7A">http://goo.gl/RSj7A</a></p>

<p>Tl;dr. <a href="http://www.raspberrypi.org/">Raspberry Pi</a> 剛剛在 HN 上紅起來的時候，我就果斷通過 ebay 從英國買了一隻。那是上學期的事情了，由於<a href="http://www.conanblog.me/life/where-are-we/">種種原因</a>，我直到最近才真正玩起來。寫這篇簡記有兩個目的，一爲了以後自己查閱配置方法方便，二爲了給明睿交差（太無聊可以直接看最後一節……）。<!--more--></p>

<ul id="markdown-toc">
  <li><a href="#section">硬件</a></li>
  <li><a href="#section-1">軟件</a>    <ul>
      <li><a href="#section-2">操作系统</a></li>
      <li><a href="#section-3">分區擴容</a></li>
    </ul>
  </li>
  <li><a href="#section-4">打印分區表</a></li>
  <li><a href="#section-5">刪除第二個分區</a></li>
  <li><a href="#section-6">新建一個分區</a></li>
  <li><a href="#section-7">!!! 第一個扇區號必須和上面刪除的分區的起始扇區號一樣，這裏的話是186368 !!!</a></li>
  <li><a href="#section-8">保存剛剛的操作並退出</a>    <ul>
      <li><a href="#section-9">系統常規設置</a></li>
      <li><a href="#section-10">聲音</a>        <ul>
          <li><a href="#vlc">VLC</a></li>
        </ul>
      </li>
      <li><a href="#wifi">WiFi</a></li>
      <li><a href="#go">Go</a></li>
      <li><a href="#section-11">後記</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">硬件</h2>

<p>Pi 本身我是買了 Model B，它跟 A 的區別只是 B 有倆 USB 口和 512MB 內存，而 A 只有一個 USB 口和 256MB 内存。東西運到的時候除了機子本身什麼都沒有，所以其他東西你得自己配。</p>

<p>最基本的是電源，理論上說，電腦 USB 口直接供电就应该可以驱动 Pi 了，可是網上有些黑客表示有起不動的現象，用測電壓的儀器測了板子，當插上一些設備後，不達5伏。所以我建議在選擇電源時可以挑高一點電壓的，比如<a href="http://www.amazon.com/gp/product/B004EYSKM8/ref=oh_details_o05_s00_i00?ie=UTF8&amp;psc=1">摩托羅拉的SPN5504型充電器</a>，它的輸出規格是5.1V，850mA。補充一句，這塊板子的最高設計電壓是5.25V。我用的這個充電器的電流還是比較小，經測試，跑不動無電源供給的外接硬盤。</p>

<p>除此之外，我還買了一個迷你 WiFi 網卡，<a href="http://www.amazon.com/gp/product/B005CLMJLU/ref=oh_details_o06_s00_i00?ie=UTF8&amp;psc=1">Edimax EW-7811Un</a>。有了 WiFi，我就可以不用非得拿一根網線接着用了，比較方便。</p>

<p>其它硬件我就不一一說了，不太算是必須品，大致是殼子、各種線（我現在只用ssh鏈接）和麪包板以及各種小電子元件（這些是用來做別的擴展的）。</p>

<h2 id="section-1">軟件</h2>

<p>由於硬件的計算能力非常有限，我選擇了 Arch Linux 作爲操作系統。非常輕量級，而且給你更多的支配權。</p>

<h3 id="section-2">操作系统</h3>

<p>Arm 版的可以在 Pi 的<a href="http://www.raspberrypi.org/downloads">官網下載</a>。這個系統裏也沒有GUI，正和我意。值得強調的是這個鏡像是hard-float ABI的，啓動非常快。</p>

<p>下載好鏡像後先檢查下 checksum：</p>

<p><code>bash
$ sha1sum ~/Downloads/archlinux-hf-2013-02-11.zip
</code></p>

<p>解壓：</p>

<p><code>bash
$ unzip ~/Downloads/archlinux-hf-2013-02-11.zip
</code></p>

<p>在插入SD卡之前，用 <code lang="bash">df -h</code> 查看當前掛載的磁盤，再插入SD卡再查看。找出你的SD卡名字，就是像 <code>/dev/mmcblk0p1</code> 或 <code>/dev/sdd1</code> 這樣的盤符。記住名字並卸載該盤符（如果這個SD卡裏有多個分區，保證卸載該SD卡下的所有盤符）,這裏我們假設是<code>mmcblk0p1</code>这个盘：</p>

<p><code>bash
$ unmount /dev/mmcblk0p1
</code></p>

<p>卸载后就可以将镜像拷贝到刚刚的SD卡裏了：</p>

<p><code>bash
$ sudo dd bs=4M if=/path/to/your/image/arch-linux.img of=/dev/mmcblk0p1
</code></p>

<h3 id="section-3">分區擴容</h3>

<p>OS 的安裝其實到這裏就算結束了，但是因爲原鏡像是2GB的，如果你的SD卡大於2GB，其他的空間就用不到了，要用就得對SD卡上的分區擴容。擴容的工具很多，有命令行的也有圖形界面的。GParted 就挺好用的，如果對命令行工具不太熟悉，它是個很好的選擇。不過在這篇簡記裏我要裝個逼：</p>

<p>&#8220;` bash
$ sudo fdisk -uc /dev/mmcblk0</p>

<h1 id="section-4">打印分區表</h1>
<p>Command (m for help): p</p>

<p>Disk /dev/mmcblk0: 3904 MB, 3904897024 bytes
64 heads, 32 sectors/track, 3724 cylinders, total 7626752 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x0004f23a</p>

<pre><code>    Device Boot      Start         End      Blocks   Id  System /dev/mmcblk0p1   *        2048      186367       92160    c  W95 FAT32 (LBA) /dev/mmcblk0p2          186368     3667967     1740800   83  Linux
</code></pre>

<h1 id="section-5">刪除第二個分區</h1>
<p>Command (m for help): d
Partition number (1-4): 2</p>

<h1 id="section-6">新建一個分區</h1>
<p>Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 2</p>

<h1 id="section-7">!!! 第一個扇區號必須和上面刪除的分區的起始扇區號一樣，這裏的話是186368 !!!</h1>
<p>First sector (186368-7626751, default 186368): 186368
Last sector, +sectors or +size{K,M,G} (186368-7626751, default 7626751): 
Using default value 7626751</p>

<h1 id="section-8">保存剛剛的操作並退出</h1>
<p>Command (m for help): w
The partition table has been altered!</p>

<p>Calling ioctl() to re-read partition table.
Syncing disks.
&#8220;`</p>

<p>檢查下磁盤，然後再擴容：</p>

<p><code>bash
$ sudo e2fsck -f /dev/mmcblk0p2
$ sudo resize2fs -p /dev/mmcblk0p2
</code></p>

<h3 id="section-9">系統常規設置</h3>

<p>Arch 起來之後裏面基本上啥都沒有，所以得根據自己的喜好調教一下。本着極簡主義的原則，我做了如下調整。先以 root 身份登錄。</p>

<p>Pi 用 SD 卡做主盤，其實就相當與 SSD 了，爲了延長 SD 卡的壽命，我把系統的<code>atime</code>記錄取消掉了，只要修改<code>/etc/fstab</code>:</p>

<p><code>
# 
# /etc/fstab: static file system information
#
# &lt;file system&gt;        &lt;dir&gt;         &lt;type&gt;    &lt;options&gt;          &lt;dump&gt; &lt;pass&gt;
devpts                 /dev/pts      devpts    defaults            0      0
shm                    /dev/shm      tmpfs     nodev,nosuid        0      0
/dev/mmcblk0p1  /boot           vfat    defaults        0       0
/dev/mmcblk0p2  /               ext4    defaults,noatime        0       0
tmpfs           /var/log        tmpfs   defaults,noatime,mode=0755,size=5%      0       0
</code></p>

<p>升級系統：</p>

<p><code>bash
$ pacman -Syu
</code></p>

<p>如果它說要先升級<code>pacman</code>，就讓它升，升完後再來一次，這樣整個系統都更新了。</p>

<p>修改默認 root 的密碼：</p>

<p><code>bash
$ passwd root
</code></p>

<p>修改默認主機名，默認是叫<code>alarmpi</code>，你可以修改<code>/etc/hostname</code>裏的此默認值。</p>

<p>Arch 默認是沒有<code>sudo</code>的，安一個：</p>

<p><code>bash
$ pacman -S sudo
$ visudo
</code></p>

<p>爲了只讓<code>sudo</code>用戶組的用戶有執行<code>sudo</code>的權限，我們還得修改一下 <code>/etc/sudoers</code>文件，用你最喜歡的文本編輯器打開，並去掉<code>%sudo ALL=(ALL) ALL</code>這一行前面的註釋，保存並關閉。</p>

<p>創建新用戶並設置密碼：</p>

<p><code>bash
$ useradd -m -g users -s /bin/bash conan
$ passwd conan
</code></p>

<p>将新用户加入到<code>sudo</code>用戶組：</p>

<p><code>bash
$ sudo usermod -aG sudo conan
</code></p>

<p>禁止<code>root</code>通過ssh登錄，打開<code>/etc/ssh/sshd_config</code>，找到<code>PermitRootLogin</code>並把它的值改成‘no’。重啓<code>sshd</code>:</p>

<p><code>bash
$ systemctl restart sshd
</code></p>

<p>修改時區設置：</p>

<p><code>bash
$ tzselect
$ export TZ='America/New_York'
$ source /etc/profile
</code></p>

<p>安裝<code>Vim</code>和<code>python2</code>：</p>

<p><code>bash
$ pacman -S vim python2
</code></p>

<p>常規設置這樣就差不多了，更新並重啓一下系統（再次更新是以防因爲以上變動之後有些包找不到）：</p>

<p><code>bash
$ pacman -Syu
$ reboot
</code></p>

<h3 id="section-10">聲音</h3>

<p>安裝<code>alsa</code>相關包：</p>

<p><code>bash
$ sudo su
$ pacman -S alsa-firmware alsa-lib alsa-plugins alsa-utils mpg123
</code></p>

<p>掛載聲音模塊：</p>

<p><code>bash
$ modprobe snd_bcm2835
</code></p>

<p>將聲音模塊放進內核模塊，這樣它會自啓動：</p>

<p><code>bash
$ vi /etc/modules-load.d/snd_bcm2835.conf
</code></p>

<p>文件裏寫：</p>

<p><code>bash
# Put snd_bcm2835.ko in kernel modules
snd_bcm2835
</code></p>

<p>因爲 Pi 的音頻可以從 analog 和 HDMI 兩個通道出來，所以我們可以做個選擇，從<a href="http://www.raspberrypi-spy.co.uk/2012/06/raspberry-pi-speakers-analog-sound-test/">官網的信息</a>看，你可以用 <code>amixer cset numid=3 &lt;n&gt;</code> 這個命令來制定通道，其中<code>&lt;n&gt;</code>可以是 0、1、2，意思是：0=auto, 1=analog, 2=hdmi。</p>

<p>測試一下是否有效：</p>

<p><code>bash
$ speaker-test -c 2
</code></p>

<p>沒問題的話你應該可以聽到一些噪音。當然你也可以通過官網的方法測試：</p>

<p><code>bash
$ wget http://www.freespecialeffects.co.uk/soundfx/sirens/police_s.wav
$ aplay police_s.wav
</code></p>

<p>如果遇到這樣的報錯：</p>

<p><code>bash
ALSA lib confmisc.c:768:(parse_card) cannot find card '0'
ALSA lib conf.c:4246:(_snd_config_evaluate) function snd_func_card_driver returned error: No such file or directory
ALSA lib confmisc.c:392:(snd_func_concat) error evaluating strings
ALSA lib conf.c:4246:(_snd_config_evaluate) function snd_func_concat returned error: No such file or directory
ALSA lib confmisc.c:1251:(snd_func_refer) error evaluating name
ALSA lib conf.c:4246:(_snd_config_evaluate) function snd_func_refer returned error: No such file or directory
ALSA lib conf.c:4725:(snd_config_expand) Evaluate error: No such file or directory
ALSA lib pcm.c:2217:(snd_pcm_open_noupdate) Unknown PCM default
aplay: main:696: audio open error: No such file or directory
</code></p>

<p>你需要把用戶加到<code>audio</code>用戶組裏：</p>

<p><code>bash
$ usermod -G audio -a conan
$ su -l conan
</code></p>

<h4 id="vlc">VLC</h4>

<p>安裝 VLC 純粹是因爲我<code>scp</code>了一份「白金迪斯科」到 Pi，發現居然解碼失敗了……以及 VLC 有個網頁端的控制接口，挺方便，可惜就是太 heavy 了。</p>

<p><code>bash
$ pacman -S vlc pulseaudio pulseaudio-alsa libao
</code></p>

<p>安裝完後把<code>/etc/libao.conf</code>裏的<code>alsa</code>換成<code>pulse</code>。之後再跑，你可能會遇到一些錯誤，那是因爲有些包還沒裝，仔細看下錯誤信息再補上就好了。上面的安裝我也不是一次到位的，也是跑跑補補，只是在寫簡記的時候重新 compile 了命令記錄。</p>

<p>爲了使用網頁控制接口，你得在<code>/usr/share/vlc/lua/http/.hosts</code>裏加上可訪問的 IP，在這裏我就開放了本地網絡的訪問權：</p>

<p><code>bash
# local network
192.168.2.0/24
</code></p>

<p>這樣應該就好了，來聽首歌試試：</p>

<p><code>bash
$ vlc --intf http --http-host 192.168.2.11 --http-port 8080 /home/conan/hikari-loveletter.mp3
</code></p>

<p>打開 Web Interface 就只需要：</p>

<p><code>bash
$ vlc --extraintf=http
</code></p>

<h3 id="wifi">WiFi</h3>

<p>Edimax EW-7811Un 是基於 Realtek 8192CU 的 WiFi 網卡。這一款在 Raspberry Pi 社区里非常有人气，因为它能被 Pi 的小電力驅動。不過貌似它的驅動程序卻還沒有成爲 alarmpi 的標配，我聽說它的驅動已經成爲 Raspbian 的標配（基於 debian 的 Pi Linux 分支），估計 alarmpi 也快了吧。不過在此之前還是得自己擼。擼之前我建議參考這篇簡記的同學先用<code>lsmod</code>查看一下當前已經掛載的模塊，如果有叫<code>8192cu</code>的，那麼恭喜你，你不用自己擼了，直接跳過本章節吧！</p>

<p>安裝前還是先更新、安裝一些必要的工具：</p>

<p><code>bash
$ sudo su
$ pacman -Syu
$ pacman -S util-linux base-devel unzip
$ reboot
</code></p>

<p><code>util-linux</code>包其實是已經安裝過的了，但是在這裏我們或許得重裝一下，這是爲了避免<code>util-linux</code>的c重啓後不能登錄的小 bug，如果重啓後不能登錄了，就<code>ssh</code>上，再重裝<code>util-linux</code>。</p>

<p>從另一臺機子下載 <a href="http://218.210.127.131/downloads/downloadsView.aspx?Langid=1&amp;PNid=21&amp;PFid=48&amp;Level=5&amp;Conn=4&amp;DownTypeID=3&amp;GetDown=false&amp;Downloads=true#2772">RTL8192CU 驅動源碼</a>(因爲這個極品的網站裏源碼是js搞的，不太容易弄直接下載地址，所以得有個有圖形界面的機子來下)。將下載好的 zip 包上傳到 Pi 裏：</p>

<p><code>bash
$ scp ~/Downloads/RTL8192xC_USB_linux_v3.4.3_4369.20120622.zip conan@192.168.2.11:/home/conan/
</code></p>

<p>下面再次回到 Pi 裏，解壓源碼：</p>

<p><code>bash
$ sudo su
$ unzip RTL819xC_USB_linux_v3.4.3_4369.20120622.zip
$ cd RTL8188C_8192C_USB_linux_v3.4.3_4369.20120622/driver/
$ tar -xvf rtl8188C_8192C_usb_linux_v3.4.3_4369.20120622.tar.gz
$ cd rtl8188C_8192C_usb_linux_v3.4.3_4369.20120622
$ vim Makefile
</code></p>

<p>這裏我們要修改一下編譯所基於的架構，首先找到<code>CONFIG_PLATFORM_I386_PC = y</code>，將‘y’改成‘n’；加上<code>CONFIG_PLATFORM_ARM_BCM2708 = y</code>，在架構配置區塊下面加上下面的代碼：</p>

<p><code>bash
ifeq ($(CONFIG_PLATFORM_ARM_BCM2708), y)
EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
ARCH := arm
CROSS_COMPILE :=
KVER  := $(shell uname -r)
KSRC := /lib/modules/$(KVER)/build
endif
</code></p>

<p>保存後就可以出來編譯了：</p>

<p><code>bash
$ make
</code></p>

<p>不出意外，這裏應該就編譯成功了，我第一次跑的時候失敗了，原因是我下錯了源代碼包……成功後在一坨新生成的文件裏有個叫<code>8192cu.ko</code>的。這就是那個將要被掛載到內核的新模塊。</p>

<p>按理說這裏只要再<code>make install</code>就好了，可是官方的 install 腳本好像有點問題，不過還是有參考意義的，至少它描述了你大概要做哪些事情來安裝新的組件。</p>

<p><code>bash
$ cp 8192cu.ko /lib/modules/$(uname -r)/kernel/net/wireless
$ depmod -a
$ insmod 8192cu.ko
$ install -p -m 644 ~/RTL8188C_8192C_USB_linux_v3.4.3_4369.20120622/driver/rtl8188C_8192C_usb_linux_v3.4.3_4369.20120622/8192cu.ko /lib/modules/($uname -r)/kernel/drivers/net/wireless/
</code></p>

<p>驅動裝完後我們還得看看有沒有衝突的驅動，用<code>mkinitcpio -M</code>查看。如果发现列表里有<code>rtl8192cu</code>，我們得禁用它才能保證新的驅動正常工作：</p>

<p><code>bash
$ echo "blacklist rtl8192cu" &gt; /etc/modprobe.d/blacklist-rtl8192cu.conf
</code></p>

<p>重啓並登錄後先看看驱动模块能不能用，如果有問題就再回到之前的部分仔細走一遍：</p>

<p><code>bash
$ sudo su
$ rmmod 8192cu
$ modprobe 8192cu
$ ip link set wlan0 up
</code></p>

<p>接着就可以裝網絡管理軟件來自動化鏈接 WiFi 了，我用的是<code>netcfg</code>，先安裝必要的工具：</p>

<p><code>bash
$ pacman -S wireless_tools netcfg
</code></p>

<p>安裝好後有些文件要配置一下，首先是創建 profile 文件：</p>

<p><code>bash
$ cp /etc/network.d/examples/wireless-wpa /etc/network.d/conan_wireless
$ vim /etc/network.d/conan_wireless
</code></p>

<p>更具自己網絡的情況填寫好相應信息，當然這裏我用的是wpa方式連的，其他模式都在<code>examples</code>目錄下，具體信息可以看 <a href="https://wiki.archlinux.org/index.php/Netcfg#Configuration">Arch wiki</a>。</p>

<p><code>/etc/conf.d/netcfg</code>也要做些修改，因爲 WiFi 的 DHCP 可能有些慢，所以最好把等待時間設置長一點，加一句<code>DHCP_TIMEOUT=30</code>；其他的配置可以更具自己的喜好自由調整。</p>

<p>最後終於可以連 WiFi 了：</p>

<p><code>bash
$ netcfg /etc/network.d/conan_wireless
</code></p>

<p>這個過程中可能會看到錯誤，但是之後如果出現了‘Done’，那就應該是連上了，可以<code>ifconfig</code>看一下。</p>

<p>最後我們要把 WiFi 鏈接自動化：</p>

<p><code>bash
$ systemctl enable net-auto-wireless.service
</code></p>

<h3 id="go">Go</h3>

<p>在 arm 上編譯 Go 我純粹是吃飽了撐着，因爲發現在 Pi 上编译还比较 tricky，所以記錄一下。先裝上必要的軟件：</p>

<p><code>bash
$ pacman -S mercurial gcc
</code></p>

<p>下載源碼：</p>

<p><code>bash
$ hg clone -u release https://code.google.com/p/go /usr/local/go
</code></p>

<p>編譯流程跟<a href="http://golang.org/doc/install/source">官網說的</a>差不多，只是在編譯之前要設置一些環境變量：</p>

<p><code>bash
$ export GOARCH="arm"
$ export GOARM="5"
$ export GOOS="linux"
$ export GOPATH="/usr/local/go/bin"
</code></p>

<p>下面接着正常編譯流程：</p>

<p><code>bash
$ cd /usr/local/go/src
$ ./all.bash
</code></p>

<p>跑完后應該會有類似這樣的信息：</p>

<p>&#8220;`
ALL TESTS PASSED</p>

<hr />
<p>Installed Go for linux/amd64 in /home/you/go.
Installed commands in /home/you/go/bin.
<em>** You need to add /home/you/go/bin to your $PATH. **</em>
&#8220;`</p>

<p>當然也有可能測試沒有完全通過的，我就遇到過，但是 bin 已經編譯成功了。這時候只需要把環境變量裏的<code>PATH</code>更新一下就可以了：</p>

<p><code>bash
$ export PATH=$PATH:/usr/local/go/bin
</code></p>

<p>最後跑個「喂世界」程序測試下。建一個<code>hello.go</code>：</p>

<p>&#8220;`go
package main</p>

<p>import “fmt”</p>

<p>func main() {
    fmt.Printf(“hello, world\n”)
}
&#8220;`</p>

<p>走起：</p>

<p><code>bash
$ go run hello.go
hello, world
</code></p>

<h2 id="section-11">後記</h2>

<p>這篇簡記基本只是一個關於 Raspberry Pi 的 setup，可能明睿更多的是希望看到各種性能相關的測評。我想性能什麼的是在預料之中的，肯定跟我們的本本沒法比啦，在編譯 Go 的時候連<code>rand</code>的測試都超時了。但是作爲一個玩具，還是挺不錯的。有了它我現在可以更節能了，下載不用整夜開着能跑「暗黑3」和「星際爭霸2」的 Linux 主機了。聽個音樂和有聲讀物也不用特意開電腦，手機還能方便操控。連着硬盤做文件stream或分享也挺方便。其實最好的一點是換SD卡方便。現在一個卡是 Arch，回頭再做張卡弄媒體中心，要用什麼就換什麼。</p>

<p>至於麪包板以及擴展的一些 Hack 我還沒玩得起來，材料還在路上，不過我已經有些想法了。比如做些指示燈和語音輸出，把平時需要關注的信息用這些媒介傳遞給我，簡單說就是把以前的 pull 換成 push。</p>

<p>綜上所述，玩這個肯定是蛋非常疼的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用另一臺計算機寫 Octopress]]></title>
    <link href="http://ConanChou.github.io/blog/octopress/hack/2012/08/23/write-octopress-in-another-box/"/>
    <updated>2012-08-23T23:26:00-04:00</updated>
    <id>http://ConanChou.github.io/blog/octopress/hack/2012/08/23/write-octopress-in-another-box</id>
    <content type="html"><![CDATA[<p>用 Octopress 寫博客已經有幾天了，一直都在家裏的臺機上寫。今天想在我的小黑上寫點東西的時候我就只是把 Github 上所有的 branch <code>clone</code> 下來，裝了改裝的東西，可是折騰半天不能從小黑上發佈。去 doc 里面看了一下，也没有这方面的记录。於是決定刨根。<!--more--></p>

<p>Octopress 的運行機制很簡單，就是用類似 <code>make</code> 的 <code>rake</code> 將寫好的 <code>markdown</code> 文件轉化成 HTML 文件，皮膚什麼的都也一併生成好，然後再把生成好的一堆靜態文件 <code>push</code> 到 Github 或其他類似的地方。我想不能推送的話應該是可以從 Rakefile 裏找到答案。果不其然：</p>

<p><code>ruby
mkdir deploy_dir
cd "#{deploy_dir}" do
  system "git init"
  system "echo 'My Octopress Page is coming soon &amp;hellip;' &gt; index.html"
  system "git add ."
  system "git commit -m \"Octopress init\""
  system "git branch -m gh-pages" unless branch == 'master'
  system "git remote add origin #{repo_url}"
  rakefile = IO.read(__FILE__)
  rakefile.sub!(/deploy_branch(\s*)=(\s*)(["'])[\w-]*["']/, "deploy_branch\\1=\\2\\3#{branch}\\3")
  rakefile.sub!(/deploy_default(\s*)=(\s*)(["'])[\w-]*["']/, "deploy_default\\1=\\2\\3push\\3")
  File.open(__FILE__, 'w') do |f|
    f.write rakefile
  end
end
</code></p>

<p>很顯然，這個 <code>deploy_dir</code> 也是一個單獨的 git 目錄。追溯其根源，也就是默認設置，就是 「_deploy」 目錄。而這個目錄是被 「.gitignore」 排除的。這就難怪爲什麼單純的 <code>clone</code> 沒法工作了。于是完整的 <code>clone</code> 过程如下（包含註解）：</p>

<p>&#8220;` bash
$ ;: go to the dir you want to put your octopress repo
$ cd ~/Documents</p>

<p>$ ;: clone repo from your exists octopress repo
$ git clone git@github.com:ConanChou/conanchou.github.com.git octopress
$ cd octopress</p>

<p>$ ;: get the source branch
$ git checkout -b source origin/source </p>

<p>$ ;: add original octopress repo to remote for updates
$ git remote add octopress https://github.com/imathis/octopress.git </p>

<p>$ ;: clone the master branch to _deploy dir
$ git clone git@github.com:ConanChou/conanchou.github.com.git _deploy</p>

<p>$ ;: install bundles
$ gem install bundler
$ bundle install
$ rake install
&#8220;`</p>

<p>Happy hacking!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[簡單粗暴解決 Zsh Home 和 End 按鍵問題]]></title>
    <link href="http://ConanChou.github.io/blog/linux/unix/zsh/hack/2012/08/20/resolve-zsh-home-and-end-key-problem/"/>
    <updated>2012-08-20T22:21:00-04:00</updated>
    <id>http://ConanChou.github.io/blog/linux/unix/zsh/hack/2012/08/20/resolve-zsh-home-and-end-key-problem</id>
    <content type="html"><![CDATA[<p>記得剛來美國那會兒，有一次在地鐵裏聽到兩位老太太聊關於手機待機時間短的話題，當中一個老太太勸另一個老太太說去找客服「Go talk to them. Don’t settle.」這句話很大程度上概括了美國人的生活態度 —— 不妥協，有不滿就去解決。這種思想對 Hack 文化也有着潛移默化的影響，用中國人的話說便是「折騰」。<!--more--></p>

<p>半年前我加入了 <code>Zsh</code> 的用戶陣營，一番配置後倒也用着挺爽。前幾天又去折騰 <code>.zshrc</code> 文件，更爽了，可是 <kbd>Home</kbd> 和 <kbd>End</kbd> 鍵工作得不正常了，就像這樣：</p>

<p>&#8220;` bash
$ H                   <br />
git push origin source</p>

<p>&#8220;`</p>

<p>按完 <kbd>Home</kbd> 鍵就在我的命令裏加了一個 H 還換行，我居然就這樣「settle」了一段時間。今天實在忍不住，找解決方案。網上的解決方案很多，也有很成熟的，比如用 <code>autoload zkbd</code>
來問答式生成按鍵和含義對應表的，可我嫌麻煩。更大部分的解決方案只是放一堆配置文件代碼，而事實上這些代碼在不同環境下是不一樣的。所以換句話說這些代碼只是治標不治本，答者沒有授問者以漁。</p>

<p>問題的本身在 <code>bindkey</code> 上。也就是說只要找到對應的按鍵和 <code>Zsh</code> 內的含義接口就可以解決問題。而含義接口就是 <code>beginning-of-line</code> 和 <code>end-of-line</code>。所以只需要找到我們的按鍵碼是什麼就可以了。下面這個小技巧可能鮮爲人知，就是利用 <code>cat</code> 來查看按鍵碼。很簡單，在命令行下直接 <code>cat</code> + <kbd>回車</kbd>，然後接着按你想知道按鍵碼的按鍵，在我的例子裏就是 <kbd>Home</kbd> 鍵：</p>

<p><code>bash
$ cat
^[OH
</code></p>

<p>接着我又得到了 <kbd>End</kbd> 鍵的按鍵碼。最後在 <code>.zshrc</code> 裏添加兩行代碼：</p>

<p><code>
bindkey "^[OH" beginning-of-line
bindkey "^[OF" end-of-line
</code></p>

<p>問題解決，簡單粗暴，但直截了當。Don’t settle. Happy hacking.</p>
]]></content>
  </entry>
  
</feed>
