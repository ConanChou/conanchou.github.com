<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: thought | conan @ notes:~/]]></title>
  <link href="http://ConanChou.github.io/categories/thought/atom.xml" rel="self"/>
  <link href="http://ConanChou.github.io/"/>
  <updated>2014-09-02T00:53:36-04:00</updated>
  <id>http://ConanChou.github.io/</id>
  <author>
    <name><![CDATA[Conan]]></name>
    <email><![CDATA[conanchou1412@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[勤與懶]]></title>
    <link href="http://ConanChou.github.io/blog/thought/2013/06/09/just-in-case-vs-just-in-time/"/>
    <updated>2013-06-09T22:02:00-04:00</updated>
    <id>http://ConanChou.github.io/blog/thought/2013/06/09/just-in-case-vs-just-in-time</id>
    <content type="html"><![CDATA[<p>「Just In Case」和「Just In Time」，前者是「以防萬一」，而後者是「正好及時」。寫這篇日誌不是爲了給大家解釋這兩個詞組的字面意思，我更想談一談它們字面意思以下的含義，以及它們在程序設計中的意義。</p>

<p>初看之下，這兩個詞組只是長得很像，似乎並沒有什麼聯繫。而事實上我覺得它們間是一種反義的聯繫。「Just In Case」的做法是在處理問題時把所有可預料的情況處理放在前面處理；「Just In Time」則相對應，總是只處理當前需要處理的問題，處理是放在當下的。所以打個形象的比喻就是前者是勤勤懇懇的人，而後者是懶惰精明的人。<!--more--></p>

<p>看到這裏，或許你會認爲前者是好的，後者是壞的。但是這也正是我想澄清的，它們並沒有好壞之分，應該說它們各有各的優勢也各有各的劣勢。此話怎講？我們來用我們學過的知識來打個比方好了。曾经我和很多人一样都有一种困惑，或者说失落感，因为大学本科课程太浅，觉得学得泛而浅；而真正开始工作了又要开始学各种更加深入而专项的知识。为什么不在本科就学呢？其实这样的教育体系是有它存在的意义的。泛而浅的知识是必要的，因为如果你从未开始探索某一领域的知识的话，在将来如果要用到的时候就很难往这一领域的知识想。比如《数学之美》的作者吴军博士就曾经是学信号处理的，而这些知识恰好在他后来的信息和语音处理领域可以得到应用。如果他之前学的，比方说，会计學，他或许最终会用一样的知识体系去解决问题，但很显然，他很有可能得走更多的弯路。所以这些在本科学到的泛而浅的知识其实就是「Just
In Case」的知识。相對應的，那些到了工作中学到的专项深入的知识大多是「Just In Time」的知识。这两种不同类型的知识我們都需要，自然可以看出 JIC 和 JIT 是各有千秋的了。</p>

<p>現在我們再把這兩個概念放到編程語言和程序設計這裏領域來說說吧。可能對編譯有所瞭解的同學會一眼認出JIT，那是一種編譯方式沒錯，不過我想說的是一個更廣一點的概念，就是「lazy」。lazy 是計算機科學裏一個處理問題的策略，說白了就是讓程序避免執行不必要的指令，從而達到提升效能的目的。lazy 這個詞跟我們平時生活中用來形容人的用法其實是一樣的，只是這裏我們似乎因爲它帶來了額外的利益，反而對 lazy
跪舔了。（再次表現出了人類的醜陋本性，嫉妒別人能夠省事，同時又無節操地喜歡對自己有利的東西。）那在程序世界裏跟 JIT 相對的概念跑哪兒去了？其實我們平時正常的、無 laziness 的編程方式就是跟 JIT 相對的編程方式了。</p>

<p>這時候可能有人會覺得，既然 lazy 式的編程方式可以幫我們節省資源，我們爲什麼不全都用這種方式？這就引出了我想說的，不同應用場景這兩種編程風格的利弊了。lazy 也不是徹底的好東西。我們拿分佈式計算裏的一個案例來舉例，Hadoop（MapReduce），如果全都採用 lazy 式的設計方案，那很有可能有些數據就總不會被算，直到被需要的那一刻，這帶來的後果就是本來能夠並行分佈式運算的，但卻因爲
lazy 變成了低效的半並行半流水線的分佈式運算。</p>

<p>聊完了編程，我們來聊聊人生好了。其實「勤奮」與「懶惰」，還真的是個哲學問題呢。有人看起來勤奮，但其實他懶惰；有人看起來懶惰，但其實他勤奮。第一類人，我們通常會用「庸庸碌碌」來形容他，而第二類人更像是「精明能幹」的。第一類人不想走出自己的 confident
zone，所以即便知道自己在做的是重複勞動，他也會「勤勤懇懇」地做下去，「懶」到不願去想有沒有更好的辦法。第二類人合理地避開不需要處理的事物，創造性地產生出可以取代現有方案的新方案，他們可能看起來做的事情並不多，但其實「勤」于思考。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[也談編程工具]]></title>
    <link href="http://ConanChou.github.io/blog/thought/tool/2013/04/21/programming-tools/"/>
    <updated>2013-04-21T18:09:00-04:00</updated>
    <id>http://ConanChou.github.io/blog/thought/tool/2013/04/21/programming-tools</id>
    <content type="html"><![CDATA[<p>我總是避免在博客裏談工具，因爲怕被扣上「工具黨」的帽子。今天看到<a href="http://www.yinwang.org/blog-cn/2013/04/20/editor-ide">王垠聊到編輯器與IDE</a>，才想起來我似乎沒有在博客中寫過相關的話題。接觸代碼世界也已經十餘年了，這一拍腦袋，覺得好多話想說。</p>

<p>首先表個態，爭論工具孰好孰壞意義不大，就跟編程語言的爭論一樣無意義，因爲這些東西都不存在絕對的「好壞」，而只存在「適合不適合」，脫離前提的討論是空泛而不切實際的。既然這樣還寫這篇博客幹嘛？只是隨想，算是滿足一下我的傾訴慾望。<!--more--></p>

<h1 id="ide">IDE</h1>

<p>IDE是個很贊的「再發明」，之所以說它是「再發明」因爲我認爲它已經被發明過，只是當時人們沒有認出它。這個我會在下一節聊。喜歡IDE的理由很簡單，因爲它特別省事，尤其是在應付編程語言的知識集遠遠大於人腦對相關知識的記憶集的時候。Java就是個再好不過的例子，它的知識集不僅龐大，而且還時常令人困惑。就其龐大而言，看看它的文檔和相關的書籍就知道，其厚度是可以考慮作爲防身道具的。而對於「令人困惑」我得稍微解釋一下。困惑來自語言中一些對類似概念的
inconsistency。比如 Java 中的 Array、ArrayList、String，我們時常要獲得它們的長度。對於Array，我們得用<code>array.length</code>，是Array的一個屬性；對於ArrayList，我們得用<code>arrayList.size()</code>，是ArrayList的一個方法；對於String，我們得用<code>string.length()</code>，是String的一個方法。</p>

<p>如果沒有IDE，那解決以上的兩大問題就必須藉助於查詢文檔，這樣一來，效率就下降了。有人說可以熟能生巧，那也只是熟手被迫擴大了自己的記憶集而已。這時候IDE的好處就顯現出來了，自動補完和語法提示拯救了大多數 Java 程序員。而且IDE與身居來就「傻瓜模式」，通常從安裝到使用都不會超過30分鐘。</p>

<p>另一個優點是伴隨它的自動化來的，我們知道IDE裏都有很多工程模板和代碼自動化工具。這些東西對於剛入門的程序員特別有用，那些文件結構和代碼結構就是一種行業標準，學習這些標準有助於使自己的成長。</p>

<p>而其缺點也是從「傻瓜模式」引入的。我有多次爲了配置IDE環境而浪費了四五個小時的經歷。簡單的加一些包、修改編譯器版本什麼的倒是容易。但是如果項目比較複雜，牽連到一些其它技術和語言，那可能會要費點心。如果你所使用的技術的社區步伐比較快，那恐怕IDE還不是很支持，或者只支持較舊版本。沒錯，IDE是爲「大多數情況」設計的，你很難保證自己正在開發的項目是不是「大多數情況」。</p>

<p>另外，IDE對用戶而言，是個黑箱，其內部運行機制我們只能靠想當然或查文檔。這也給定製化IDE造成了一定的難度。不知你有沒有遇到過，反正我是遇到過一些小問題怎麼調都有問題，之後重啓IDE或重裝才好。不管問題到後來有沒有解決，都讓你感到莫名其妙。所以現在市場上比較好用的IDE都是非常有針對性的，很少能做到一個IDE就滿足大部分開發需求的，即使有，其體驗也令人着急。</p>

<p>最後是有關權限的問題。用 Windows 的用戶可能不太會遇到我所描述的情況，但是相信用 Linux/Unix 的朋友應該是遇到過類似的。就是項目放在一個不屬於用戶權限的目錄下，要編輯的時候就必須給IDE super user的權限，而IDE的行爲很多時候都是黑箱，且可能涉及到除要修改的文件以外的其它項目文件，我要非常小心地操作，因爲「權利越大，責任越大」。</p>

<h1 id="section">編輯器</h1>

<p>在這個討論中，與IDE相對的就是文本編輯器了。文本編輯器的種類可就多了，有經典的 Vi 和 Emacs，還有較爲現代的TextMate, Sublime。這個小節裏我將特指文本編輯器爲那些有較好CLI支持的編輯器。爲什麼？你應該還記得我在前一節說到IDE是被重新發明的吧，其實我想說，IDE初見端倪還是在Unix環境下。我並不是第一個這麼說的人，如果你看過我們翻譯的<a href="http://conanchou.github.io/Unix-as-IDE--Chinese-/">「Unix as
IDE」</a>，你就應該明白爲什麼我這麼說了。這裏我簡單闡述下：首先是Unix/Linux
shell下能實現幾乎所有現代IDE的功能，它甚至能更好地實現。而shell下的可編程性又使得個性化配置變得簡單可控。所以上面提到的IDE的缺點被全部修正。當然隨之而來的是易用性問題。如果僅僅是用好shell下的編輯器，其學習曲線倒也還可以接受；但是要把Unix/Linux當作IDE一樣用好，可能不花上個一兩年是不行的。不過這中時間投資是值得的。</p>

<p>這種靈活性和可編程性很大程序上得益於之前被王垠噴的Unix/Linux的以字符爲通信媒介的設計思路。Unix/Linux的設計中，有很多「只做一件事並把事情做到最好」的小程序，這些小程序接受字符串命令並執行。這樣一來，它們即可以單獨運行，也可以作爲一個更大作業的一部分來運行。正是因爲字符串式的控制方式，我們才能如此靈巧地使用這些小程序。想想看，如果這些小程序都是通過對用戶不友好的API來呼叫，系統會怎麼樣？變快了，可是丟失了一些靈活性。這種靈活性，我常常用一個比方來說明它，試想待解決的各種問題就像用石塊鋪的地面，要想弄平整這塊地面，就必須拿那些顆粒更小的黃沙來填充溝壑。而Unix/Linux的這種設計思路正是這種黃沙，這才使得Unix/Linux可以勝任幾乎任何工作。</p>

<p>上面扯的這些可能在沒有相關經驗的人看來有點空，下面我們來點接地氣的，說說我是怎麼用 Vim 以及相關集成環境的吧。由於工作需要，我得寫
Python、Ruby、PHP、Java、Go、JS等相關的程序（其實還包括我現在寫博客的markdown在內的很多文件支持，這裏就不一一列舉了），項目中出現多語言的情況也很多。爲了適應這種詭異的需求，我寫了一套<a href="https://github.com/ConanChou/ConanVimrc">自己的Vim配置</a>。不同編程語言的支持，對我來說只要有語法高亮和正確的縮進以及不用太智能的自動補全就差不多了。除此之外，剛剛我說了很多它的靈活性，例子之一就是我在做RoR開發的時候，TDD就是用 <a href="http://joshuadavey.com/2012/01/10/faster-tdd-feedback-with-tmux-tslime-vim-and-turbux/">Vim + tmux
的快速反饋</a>的方式來做的。那這麼做到底有多爽呢？感覺很像是Emacs下用<a href="http://common-lisp.net/project/slime/">slime</a>做clisp的開發，隨寫隨eval。這些功能性都是較現代IDE有過之而無不及的。</p>

<p>說完功能性，我還覺得使用文本編輯器寫程序能使你更快地變成更好的程序員，至少對我來說是這樣。爲什麼這麼說，首先是「去自動化」，這些經典文本編輯器都是有非常完備的自動化功能的，但是並不會像現代IDE那麼簡單獲得。於是在順利使用各種自動化提高效率之前，你可能得手動做好多從零開始的事情。在此過程中你可以學習到很多技術細節。比如說用某某框架，一些現代IDE可以自動生成好多東西，包括一些配置文件也都是點點按鈕。其實這些技術細節都在那一堆項目文件裏，如果能經自己手，並在特殊情況下按照自己的需要修改這些文件的話，你學到的要比用IDE生成來的多而且快。有些東西，是欲速則不達的。</p>

<p>再來便是思維訓練。記得剛剛學習變成那會兒還只是簡單的藍色窗口下的BASIC，出了問題了只能靠<code>print</code>和想，沒有先進的debugger。後來用上了IDE之後一度迷戀上使用圖形界面debugger這種便利的工具。後來發現，其實往往通過推理的方式來debug更加有效，甚至能預見到還未出現的bug。文本編輯器裏沒有什麼便利的debugger，要用也只能用命令行下的debug工具。這時候你只要還有點惰性，就不太希望輕易使用debug工具。這種思維訓練提供了我全局思考和程序化思維的能力，變成一個活解釋器也不是壞事不是嗎？</p>

<h1 id="section-1">根源？</h1>

<p>我曾看到<a href="http://developers.slashdot.org/story/12/10/30/065244/the-ide-as-a-bad-programming-language-enabler">這樣一種說法</a>，說如果一門語言設計得足夠好的話，IDE是一種多餘的存在。因爲IDE本身就是爲了很大程度上彌補語言設計的不足。聽起來有點偏激？我暫不置評吧，畢竟這篇日誌是談工具，而語言，作爲生產材料，或許可以作爲以後某篇日誌的主題。引入這個評論，其實我是想說分析生產工具無法徹底將其與生產材料分開討論。而確實，不同的編程語言其需要的自動化類型也是不同的。對於設計較差的編程語言，自動化可能更多的是在生成代碼上。而對設計較好的編程語言，自動化可能更多的是放在生產環節上，比如自動測試、編譯、部署等。生產環節的自動化往往是需要很強靈活性的，而前面我也已經說了，這種靈活性恐怕是大多數IDE不具備的，除非有像google內部專門的team做相關的IDE定製化開發的支持。</p>

<p>先拋開語言的優劣，我覺得目前我看到的最想用的IDE就是<a href="http://www.lighttable.com/">LightTable</a>。當然，如果它能兼備靈活性，我會果斷拋棄現在我在使用的開發環境方案。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[道不明，術不精]]></title>
    <link href="http://ConanChou.github.io/blog/thought/2013/04/20/dao-bu-ming-shu-bu-jing/"/>
    <updated>2013-04-20T01:20:00-04:00</updated>
    <id>http://ConanChou.github.io/blog/thought/2013/04/20/dao-bu-ming-shu-bu-jing</id>
    <content type="html"><![CDATA[<p>「道不明，術不精」是現在最適合形容我狀態的語句。說真的，我對自己有些失望。從兩千年初開始接觸計算機和因特網，到現在幾乎沒有什麼大的成就。對照 Coding Horror 裏的<a href="http://www.codinghorror.com/blog/2009/04/the-eight-levels-of-programmers.html">《程序員的八個等級》</a>，我大概在4～5吧。而很顯然這不應該是一個有志者所止步的位置。我最接近「Famous」的恐怕也只有幾年前趕鴨子上架般的在亞太開源軟件峯會上給的關於 CakePHP 和 Symfony
的講座吧。我一直在學習，可長進不足。到底是哪裏做得不對？<!--more--></p>

<p>上上週考算法，這週又有電話面試，所以最近一個月把<a href="http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844/ref=sr_1_2?ie=UTF8&amp;qid=1366437541&amp;sr=8-2&amp;keywords=intro+to+algo">《Introduction to Algorithms》</a>和<a href="http://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/098478280X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1366437600&amp;sr=1-1&amp;keywords=cracking+the+coding+interview">《Cracking the Coding Interview》</a>過了一遍。同時看了一小半<a href="http://www.amazon.com/What-Technology-Wants-Kevin-Kelly/dp/0143120174/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1366437694&amp;sr=1-1&amp;keywords=what+technology+wants">《What Technology
Wants》</a>和<a href="http://book.douban.com/subject/2567698/">《三體》</a>前兩部。感覺明白了一些東西，可是又不明確到足以用語言表達的程度。所以我將僅陳述一些事實和我零碎的想法。我相信人類的大腦在接收了這些信息後可以感悟出相近的思想。</p>

<h1 id="section">學習的困難</h1>

<p>語言的形成給知識的記錄和傳播提供了必要的基礎。而語言其本身，是人類思想的一種編碼方式。一般情況下，所謂的「讀懂」只是解碼成功的代名詞。因爲人類智商大致一樣，所以大多數書本的知識並不會困難到無法理解，真正使你無法理解的原因是缺失解碼需要的額外知識。而那些額外知識可能在其他書本裏。</p>

<p>從地球上出現私有制開始，人類就已經將「自私」深深埋入自己的基因。真理往往簡單到讓你感到不真實。可得到真理的部分人並不希望別人輕鬆地獲得真理，別人也必須要花不少於自己所花的時間才公平。於是他們喜歡在「編碼」的時候故弄玄虛。當然，也有可能是出於多得到些稿費的原因。於是怪圈就形成了。但一旦你能識破怪圈，怪圈也會隨之消失。所要做的只是耐心。</p>

<h1 id="section-1">人與科技</h1>

<p>人類的科技放在宇宙尺度來看確實是爆炸式的，就像生物的出現、人類的演化也幾乎都是爆炸式的一樣。爲什麼是這樣，直到凱文凱利點破了科技是更高級的生命時我才恍然大悟。科技並不只是人類缺失能力的補足，而是像物種間的相互利用一樣，人離不開科技，科技離不開人。於是，適用於其他生物的公理也適用於科技。於是科技和生物一樣，有生存、繁衍和進化的需要。說到進化就不得不談DNA。人類的異性交配而交換DNA的方式大大提高多樣性，也進而增大了進化的可能性。而對於科技而言，它們的DNA是什麼呢？是「道」和「術」。</p>

<p>科技和科學到底是個什麼樣的關係？科技是「道」和「術」的集合，她既是指導思想，也是技巧方法。而科學就僅僅是研究其「道」，是學問。「道」像海上的明燈，指明方向；而「術」像划船的方法，用於前行。二者缺一不可。</p>

<h1 id="section-2">我的問題</h1>

<p>科技孕育於人類，這就迴歸到我了。「道不明」會導致沒有爆發力，就會像輪胎陷在泥潭裏一樣使不上力；久而久之必然「術不精」，在泥潭裏的各種掙扎，用盡了辦法（術），到頭來也不知道什麼術可行、也不知自己會什麼術。也就是說，要想孕育出更好的科技，就必須道術兼備，且要像DNA交換那麼富於變化。除此之外，就是不停地嘗試，畢竟富於變化的DNA並沒有任何質量上的保障。</p>

<p>一年前我還把計算機科學叫做「人造科學」，因爲覺得有別與自然科學，她似乎是人「生造」出來的。可是我現在又覺得這樣說不確切了。我們都知道計算機科學跟數學的淵源，可以說計算機科學完全構建於數學之上，當然這裏的數學包括邏輯學。如果僅僅從這裏看，說她人造科學也合情合理。可是我目光短淺了。數學又來自哪裏？數學是一切的抽象，當然也包括自然科學。（有興趣的話可以看一下BBC的The History of
Mathematics）如果從這個意義上來說計算機科學是一切科學的虛擬化。所以我一度覺得計算機科學的核心是術多於道的想法是大錯特錯的，其道很深，還來自除了大家已經爛熟於心的計算存儲原理和圖靈機以外的方方面面。這顯然是我一輩子都沒法學得完的。</p>

<p>當想明白了這些，再回頭看看程序員的八個等級，排在前列的都是偉大的「父親」或「母親」。他們孕育了更加優質的科技。現在我要做的已然很清晰。</p>
]]></content>
  </entry>
  
</feed>
